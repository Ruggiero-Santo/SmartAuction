from web3 import Web3
import time
import json

'''
This python script is the solution to the problem of the emission of the events
that mark the various phases of the auctions. Instead of using solutions such as
Ethereum Alarm Clock, this script has been created with the same function.

If neither is used, the only solution is to have events output when a function
is called by a participant. This means charging the cost of the event to the
participant and not having the certainty that the events are sent when the phase
has actually started.

Types of events:
    s -> start_auction
    e -> end_auction
    w -> new_phase_withdrawal(only Vick)
    o -> new_phase_opening(only Vick)

'''
# event_type = ["s", "e", "w", "o"]

events = {
# block_num: [{"type_event": "", "id_auction": 0}]
}

# In DApp folder is "build\\contracts" or
# you can create the file through the deployment done directly with RemixIDE
with open('PATH_TO\\AuctionHouse.json', 'r') as abi_definition:
    house_abi = json.load(abi_definition).get("abi", None)
# we only need Vickrey because Dutch's events are the same 
with open('PATH_TO\\Vickrey.json', 'r') as abi_definition:
    vikrey_abi = json.load(abi_definition).get("abi", None)
 
house_address = "YOUR_ADDRESS"
auctioneer_address = "YOUR_ADDRESS"
auctioneer_private_key = "YOUR_KEY"


# NOTE: this is wss for Ropsten TestNet 
infura_url = "wss://ropsten.infura.io/ws/v3/INFURA_KEY"
web3 = Web3(Web3.WebsocketProvider(infura_url))

def send_event():
    '''
    Function to send the events that have been previously scheduled. The events
    are issued according to the current block number. 
    The cost of the transaction fees are deliberately inflated in order to have
    the transaction included in the first useful block.
    '''
    lst_block = web3.eth.blockNumber + 1
    event_to_thow = events.get(lst_block, None)
    if event_to_thow:
        for e in event_to_thow:
            print("--Python throw_event.py: Lancio evento: ", str(e))
            # Make the json that represents the transaction with all the information necessary for the correct execution of the transaction
            nonce = web3.eth.getTransactionCount(auctioneer_address)
            trans = house_contract.functions.send_state_event(int(e.get("id_auction")), e.get("type_event")).buildTransaction({
                'gasPrice': web3.toWei(50, 'gwei'), #I pay a lot of money so I'm sure they'll make it as soon as possible.
                'gas': 50000, # the cost in general is about 29k I give more to avoid problems
                'nonce': nonce,
                "from": auctioneer_address})
            # The transaction must be signed with the astator's private key.
            signed_txn = web3.eth.account.signTransaction(trans, auctioneer_private_key)
            res = web3.eth.sendRawTransaction(signed_txn.rawTransaction)
            print("--Python throw_event.py: Transaction hash: ", str(res))
        del events[lst_block]

def handle_event(event):
    '''
    I manage the event generated by the auction house when a new auction is
    created. When this event is generated other events are scheduled that will
    notify the beginning and the end of the auction.
    For the vickrey are also generated the events that mark the various phases.
    '''
    
    print("--Python throw_event.py: New event of creation in the block: "+ str(event.blockNumber)+ " Auction Type: " + event.args.auction_type)
    
    nb = event.blockNumber
    vickrey_contract = web3.eth.contract(address = event.args.auction_address, abi = vikrey_abi)
    auction_id = vickrey_contract.functions.id().call()

    #Event for the beginning of the auction
    start = vickrey_contract.functions.starting_block().call()
    events.update({start: [{"type_event": "s", "id_auction": auction_id}]})
    #Event for the end of the auction
    events.update({start+vickrey_contract.functions.block_to_live().call(): [{"type_event": "e", "id_auction": auction_id}]})
    if event.args.auction_type == "Vickrey":
        #Event for the start of the withdrawal phase
        events.update({start+vickrey_contract.functions.commitment_btl().call(): [{"type_event": "w", "id_auction": auction_id}]})
        #Event for the start of the opening phase
        events.update({start+vickrey_contract.functions.withdrawal_btl().call(): [{"type_event": "o", "id_auction": auction_id}]})

def log_loop(event_filter, poll_interval):
    '''
    Very rudimentary demon that checks every two seconds if there are new events
    and if you have to issue new ones 
    '''
    while True:
        #Acquire all new generated events that respect the thread
        for event in event_filter.get_new_entries():
            handle_event(event)
            print("--Python throw_event.py: ", events)
        send_event()
        time.sleep(poll_interval)

if __name__ == "__main__":
    print("--Python throw_event.py: Started...")
    # Creation of the object that shapes the contract of the auction house
    house_contract = web3.eth.contract(address = house_address, abi = house_abi)
    # filter for event control inside the blockchain, only on the last mined
    # block every 2 sec (only the AuctionHouse newAuction event is acquired)
    block_filter = house_contract.events.newAuction.createFilter(fromBlock="latest")
    log_loop(block_filter, 2)
